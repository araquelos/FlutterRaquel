// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.8 (swiftlang-5.8.0.124.2 clang-1403.0.22.11.100)
// swift-module-flags: -target arm64-apple-ios12.2 -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -Onone -module-name VoxAuth
// swift-module-flags-ignorable: -enable-bare-slash-regex
import CommonCrypto
import CoreLocation
import CryptoKit
import Darwin
import Dispatch
import Firebase
import FirebaseAnalytics
import FirebaseMessaging
import Foundation
import KeychainAccess
import Swift
import SystemConfiguration
import UIKit
@_exported import VoxAuth
import _Concurrency
import _StringProcessing
public enum ReachabilityError : Swift.Error {
  case FailedToCreateWithAddress(Darwin.sockaddr_in)
  case FailedToCreateWithHostname(Swift.String)
  case UnableToSetCallback
  case UnableToSetDispatchQueue
}
@available(*, unavailable, renamed: "Notification.Name.reachabilityChanged")
public let ReachabilityChangedNotification: Foundation.NSNotification.Name
extension Foundation.NSNotification.Name {
  public static let reachabilityChanged: Foundation.Notification.Name
}
public class Reachability {
  public typealias NetworkReachable = (VoxAuth.Reachability) -> ()
  public typealias NetworkUnreachable = (VoxAuth.Reachability) -> ()
  @available(*, unavailable, renamed: "Conection")
  public enum NetworkStatus : Swift.CustomStringConvertible {
    case notReachable, reachableViaWiFi, reachableViaWWAN
    public var description: Swift.String {
      get
    }
    public static func == (a: VoxAuth.Reachability.NetworkStatus, b: VoxAuth.Reachability.NetworkStatus) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum Connection : Swift.CustomStringConvertible {
    case none, wifi, cellular
    public var description: Swift.String {
      get
    }
    public static func == (a: VoxAuth.Reachability.Connection, b: VoxAuth.Reachability.Connection) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public var whenReachable: VoxAuth.Reachability.NetworkReachable?
  public var whenUnreachable: VoxAuth.Reachability.NetworkUnreachable?
  final public let reachableOnWWAN: Swift.Bool
  public var allowsCellularConnection: Swift.Bool
  public var notificationCenter: Foundation.NotificationCenter
  public var currentReachabilityString: Swift.String {
    get
  }
  @available(*, unavailable, renamed: "connection")
  public var currentReachabilityStatus: VoxAuth.Reachability.Connection {
    get
  }
  public var connection: VoxAuth.Reachability.Connection {
    get
  }
  required public init(reachabilityRef: SystemConfiguration.SCNetworkReachability)
  convenience public init?(hostname: Swift.String)
  convenience public init?()
  @objc deinit
}
extension VoxAuth.Reachability {
  public func startNotifier() throws
  public func stopNotifier()
  public var isReachable: Swift.Bool {
    get
  }
  public var isReachableViaWWAN: Swift.Bool {
    get
  }
  public var isReachableViaWiFi: Swift.Bool {
    get
  }
  public var description: Swift.String {
    get
  }
}
public enum CipherError : Swift.Error {
  case encrypt
  case decrypt
  public static func == (a: VoxAuth.CipherError, b: VoxAuth.CipherError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public protocol Cipher : AnyObject {
  func encrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  func encrypt(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  func decrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  func decrypt(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
}
extension VoxAuth.Cipher {
  public func encrypt(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  public func decrypt(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
}
@_hasMissingDesignatedInitializers public class ArrayOfAuthenticationMethod {
  public var AuthenticationMethodArr: [VoxAuth.AuthenticationMethod]
  @objc deinit
}
@objc(HashFunction) public class HashFunction : ObjectiveC.NSObject {
  public var algorithm: any VoxAuth.HashAlgorithm.Type
  public func digest(_ message: Foundation.Data) -> Foundation.Data
  public init(_ algorithm: any VoxAuth.HashAlgorithm.Type)
  @objc deinit
}
extension VoxAuth.HashFunction {
  public static func == (lhs: VoxAuth.HashFunction, rhs: VoxAuth.HashFunction) -> Swift.Bool
}
extension VoxAuth.HashAlgorithm {
  public static var hashFunction: VoxAuth.HashFunction {
    get
  }
}
infix operator <<< : BitwiseShiftPrecedence
infix operator >>> : BitwiseShiftPrecedence
extension Swift.FixedWidthInteger {
  public static func <<< (lhs: Self, rhs: Self) -> Self
  public static func >>> (lhs: Self, rhs: Self) -> Self
}
final public class Poly1305 : VoxAuth.Authenticator {
  public enum Error : Swift.Error {
    case authenticateError
    public static func == (a: VoxAuth.Poly1305.Error, b: VoxAuth.Poly1305.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public static let blockSize: Swift.Int
  public init(key: Swift.Array<Swift.UInt8>)
  final public func authenticate(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  @objc deinit
}
extension Swift.String {
  public var xmlLocalName: Swift.String {
    get
  }
  public func toInt() -> Swift.Int?
  public func toInt(defaultValue: Swift.Int) -> Swift.Int
  public func toUInt() -> Swift.UInt?
  public func toUInt(defaultValue: Swift.UInt) -> Swift.UInt
  public func toInt8() -> Swift.Int8?
  public func toInt8(defVal: Swift.Int8) -> Swift.Int8
  public func toUInt8() -> Swift.UInt8?
  public func toUInt8(defVal: Swift.UInt8) -> Swift.UInt8
  public func toInt16() -> Swift.Int16?
  public func toInt16(defVal: Swift.Int16) -> Swift.Int16
  public func toUInt16() -> Swift.UInt16?
  public func toUInt16(defVal: Swift.UInt16) -> Swift.UInt16
  public func toInt32() -> Swift.Int32?
  public func toInt32(defVal: Swift.Int32) -> Swift.Int32
  public func toUInt32() -> Swift.UInt32?
  public func toUInt32(defVal: Swift.UInt32) -> Swift.UInt32
  public func toInt64() -> Swift.Int64?
  public func toInt64(defVal: Swift.Int64) -> Swift.Int64
  public func toUInt64() -> Swift.UInt64?
  public func toUInt64(defVal: Swift.UInt64) -> Swift.UInt64
  public func toFloat() -> Swift.Float?
  public func toFloat(defVal: Swift.Float) -> Swift.Float?
  public func toDouble() -> Swift.Double?
  public func toDouble(defVal: Swift.Double) -> Swift.Double?
  public func toDate() -> Foundation.Date?
  public func toDate(dateformat: Swift.String) -> Foundation.Date?
}
public enum SHA1 : VoxAuth.HashAlgorithm {
  public static var outputSize: Swift.UInt {
    get
  }
  public static var blockSize: Swift.UInt {
    get
  }
}
extension VoxAuth.SHA1 : VoxAuth.MerkleDamgardConstructor {
  public static var endianess: VoxAuth.Endianess {
    get
  }
  public static var initializationVector: [Swift.UInt32] {
    get
  }
  public static var rounds: Swift.UInt {
    get
  }
  public static func compress(_ data: Foundation.Data) -> [Swift.UInt32]
  public typealias BaseUnit = Swift.UInt32
}
public protocol SHA2Variant : VoxAuth.MerkleDamgardConstructor {
  static var kConstants: [Self.BaseUnit] { get }
  static var s0ShiftAndRotateAmounts: (Self.BaseUnit, Self.BaseUnit, Self.BaseUnit) { get }
  static var s1ShiftAndRotateAmounts: (Self.BaseUnit, Self.BaseUnit, Self.BaseUnit) { get }
  static var S0ShiftAndRotateAmounts: (Self.BaseUnit, Self.BaseUnit, Self.BaseUnit) { get }
  static var S1ShiftAndRotateAmounts: (Self.BaseUnit, Self.BaseUnit, Self.BaseUnit) { get }
}
extension VoxAuth.SHA2Variant {
  public static var endianess: VoxAuth.Endianess {
    get
  }
  public static var rounds: Swift.UInt {
    get
  }
  public static func compress(_ data: Foundation.Data) -> [Self.BaseUnit]
}
public func dateToString(date: Foundation.Date?, format: Swift.String!) -> Swift.String
@_inheritsConvenienceInitializers @objc(DeviceInfo) public class DeviceInfo : ObjectiveC.NSObject {
  @objc override dynamic public init()
  @objc public var Brand: Swift.String
  @objc public var Board: Swift.String
  @objc public var Device: Swift.String
  @objc public var Software: Swift.String
  @objc public var SoftwareRooted: Swift.Bool
  @objc public var SoftwareVersion: Swift.String
  @objc public var Model: Swift.String
  @objc public var IMEI: [Swift.String]
  @objc public var MAC: Swift.String
  @objc public var SerialNumber: Swift.String
  @objc public var Latitude: Swift.String
  @objc public var Longitude: Swift.String
  @objc public var RegistrationAppID: Swift.String
  @objc public var UUID: Swift.String
  @objc public var NicknameDevice: Swift.String
  @objc public func set(nickname: Swift.String)
  @objc deinit
}
@_hasMissingDesignatedInitializers public class ArrayOfString {
  public var stringArr: [Swift.String?]
  @objc deinit
}
public protocol HashAlgorithm {
  static var outputSize: Swift.UInt { get }
  static var blockSize: Swift.UInt { get }
  static func digest(_ message: Foundation.Data) -> Foundation.Data
}
public protocol _UInt8Type {
}
extension Swift.UInt8 : VoxAuth._UInt8Type {
}
extension Swift.UInt8 {
  public func bits() -> [VoxAuth.Bit]
  public func bits() -> Swift.String
}
@_hasMissingDesignatedInitializers @objc(GenericException) public class GenericException : ObjectiveC.NSObject {
  @objc public var localizedDescription: Swift.String {
    @objc get
  }
  @objc public func getMessage() -> Swift.String
  @objc public func getErrorCode() -> Swift.Int
  @objc deinit
}
final public class SHA3 {
  final public let blockSize: Swift.Int
  final public let digestLength: Swift.Int
  public enum Variant : Swift.RawRepresentable {
    case sha224, sha256, sha384, sha512
    public typealias RawValue = Swift.Int
    public var rawValue: VoxAuth.SHA3.Variant.RawValue {
      get
    }
    public init?(rawValue: VoxAuth.SHA3.Variant.RawValue)
  }
  public init(variant: VoxAuth.SHA3.Variant)
  final public func calculate(for bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  @objc deinit
}
extension VoxAuth.SHA3 : VoxAuth.Updatable {
  final public func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = false) throws -> Swift.Array<Swift.UInt8>
}
@_inheritsConvenienceInitializers @objc(AuthenticationMethod) public class AuthenticationMethod : ObjectiveC.NSObject {
  @objc override dynamic public init()
  @objc public var IDAuthenticationMethod: Swift.Int64
  @objc public var IDAuthenticationMethodType: Swift.Int
  @objc public var NameAuthenticationMethodType: Swift.String
  @objc public var Validity: Swift.String
  @objc public var PassSize: Swift.String
  @objc public var PassGenerationTime: Swift.String
  @objc public var Cryptography: Swift.String
  @objc public var DisplayNumber: Swift.String
  @objc public var Key: Swift.String
  @objc public var Status: Swift.String
  @objc public var ProjectID: Swift.String
  @objc public var Percentual: Swift.UInt8
  @objc public var CanCreateNew: Swift.Bool
  @objc public var IDMobileDevice: Swift.String
  @objc public func getAuthenticationMethodType() -> VoxAuth.AuthenticationMethodType
  @objc public func getOTPAlgorithm() -> VoxAuth.OTPAlgorithm
  @objc public func getStatusType() -> VoxAuth.StatusType
  @objc deinit
}
@objc public enum AuthenticationMethodType : Swift.Int {
  case UNKNOWN_DEVICE = 0
  case MOBILE_TOKEN = 1
  case CHALLENGE_RESPONSE = 2
  case QRCODE = 3
  case PUSH = 4
  case PUSH_REVERSE = 5
  case SMS = 6
  case SMS_REVERSE = 7
  case EMAIL = 8
  case URA = 9
  case FACE_RECOGNITION = 10
  case FINGERPRINT = 11
  case SPEECH_RECOGNITION = 12
  public func toString() -> Swift.String
  public var name: Swift.String {
    get
  }
  public var description: Swift.String {
    get
  }
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
@objc public enum StatusType : Swift.Int {
  case UNKNOWN_STATUS = 0
  case DEVICE_LOCKED = 1
  case LOCKED_CUMULATIVE = 2
  case LOCKED_MAX_TRY = 3
  case CLIENT_LOCKED = 4
  case CLIENT_WITHOUT_ACTIVE_DEVICES = 5
  case CLIENT_WITHOUT_ACTIVE_UNLOCKED = 6
  case CLIENT_DISABLED = 7
  case MAX_LOCKED = 8
  case DEVICE_ACTIVATION_PENDING = 9
  case DEVICE_NOT_REGISTERED = 10
  case DEVICE_DISABLED = 11
  case USE_CLOSED = 12
  case MAX_ACTIVE_DEVICES = 13
  case MAX_DEVICE_USE = 14
  case DEVICE_OUT_OF_VALIDITY = 15
  case CLIENT_NOT_FOUND = 16
  case MAX_DEVICE_IN_MOBILE = 17
  case DEVICE_MOBILE_NOT_REGISTERED = 18
  case DEVICE_MOBILE_DISABLED = 19
  case USING_CLOSED_DEVICE = 20
  case DEVICE_AVAILABLE = 21
  case DEVICE_MOBILE_ACTIVATION_PENDING = 22
  public func toString() -> Swift.String
  public var name: Swift.String {
    get
  }
  public var description: Swift.String {
    get
  }
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
extension VoxAuth.HMAC {
  convenience public init(key: Swift.String, variant: VoxAuth.HMAC.Variant = .md5) throws
}
extension VoxAuth.HashFunction {
  public static var md5: VoxAuth.HashFunction {
    get
  }
  public static var sha1: VoxAuth.HashFunction {
    get
  }
  public static var sha224: VoxAuth.HashFunction {
    get
  }
  public static var sha256: VoxAuth.HashFunction {
    get
  }
  public static var sha384: VoxAuth.HashFunction {
    get
  }
  public static var sha512: VoxAuth.HashFunction {
    get
  }
}
public protocol XMLIndexerDeserializable {
  static func deserialize(_ element: VoxAuth.XMLIndexer) throws -> Self
}
extension VoxAuth.XMLIndexerDeserializable {
  public static func deserialize(_ element: VoxAuth.XMLIndexer) throws -> Self
}
public protocol XMLElementDeserializable {
  static func deserialize(_ element: VoxAuth.XMLElement) throws -> Self
}
extension VoxAuth.XMLElementDeserializable {
  public static func deserialize(_ element: VoxAuth.XMLElement) throws -> Self
}
public protocol XMLAttributeDeserializable {
  static func deserialize(_ attribute: VoxAuth.XMLAttribute) throws -> Self
}
extension VoxAuth.XMLAttributeDeserializable {
  public static func deserialize(attribute: VoxAuth.XMLAttribute) throws -> Self
}
extension VoxAuth.XMLIndexer {
  public func value<T>(ofAttribute attr: Swift.String) throws -> T where T : VoxAuth.XMLAttributeDeserializable
  public func value<T>(ofAttribute attr: Swift.String) -> T? where T : VoxAuth.XMLAttributeDeserializable
  public func value<T>(ofAttribute attr: Swift.String) throws -> [T] where T : VoxAuth.XMLAttributeDeserializable
  public func value<T>(ofAttribute attr: Swift.String) throws -> [T]? where T : VoxAuth.XMLAttributeDeserializable
  public func value<T>(ofAttribute attr: Swift.String) throws -> [T?] where T : VoxAuth.XMLAttributeDeserializable
  public func value<T>() throws -> T where T : VoxAuth.XMLElementDeserializable
  public func value<T>() throws -> T? where T : VoxAuth.XMLElementDeserializable
  public func value<T>() throws -> [T] where T : VoxAuth.XMLElementDeserializable
  public func value<T>() throws -> [T]? where T : VoxAuth.XMLElementDeserializable
  public func value<T>() throws -> [T?] where T : VoxAuth.XMLElementDeserializable
  public func value<T>() throws -> T where T : VoxAuth.XMLIndexerDeserializable
  public func value<T>() throws -> T? where T : VoxAuth.XMLIndexerDeserializable
  public func value<T>() throws -> [T] where T : VoxAuth.XMLIndexerDeserializable
  public func value<T>() throws -> [T]? where T : VoxAuth.XMLIndexerDeserializable
  public func value<T>() throws -> [T?] where T : VoxAuth.XMLIndexerDeserializable
}
extension VoxAuth.XMLElement {
  public func value<T>(ofAttribute attr: Swift.String) throws -> T where T : VoxAuth.XMLAttributeDeserializable
  public func value<T>(ofAttribute attr: Swift.String) -> T? where T : VoxAuth.XMLAttributeDeserializable
}
public enum XMLDeserializationError : Swift.Error, Swift.CustomStringConvertible {
  case implementationIsMissing(method: Swift.String)
  case nodeIsInvalid(node: VoxAuth.XMLIndexer)
  case nodeHasNoValue
  case typeConversionFailed(type: Swift.String, element: VoxAuth.XMLElement)
  case attributeDoesNotExist(element: VoxAuth.XMLElement, attribute: Swift.String)
  case attributeDeserializationFailed(type: Swift.String, attribute: VoxAuth.XMLAttribute)
  @available(*, unavailable, renamed: "implementationIsMissing(method:)")
  public static func ImplementationIsMissing(method: Swift.String) -> VoxAuth.XMLDeserializationError
  @available(*, unavailable, renamed: "nodeHasNoValue(_:)")
  public static func NodeHasNoValue(_: VoxAuth.IndexOps) -> VoxAuth.XMLDeserializationError
  @available(*, unavailable, renamed: "typeConversionFailed(_:)")
  public static func TypeConversionFailed(_: VoxAuth.IndexingError) -> VoxAuth.XMLDeserializationError
  @available(*, unavailable, renamed: "attributeDoesNotExist(_:_:)")
  public static func AttributeDoesNotExist(_ attr: Swift.String, _ value: Swift.String) throws -> VoxAuth.XMLDeserializationError
  @available(*, unavailable, renamed: "attributeDeserializationFailed(_:_:)")
  public static func AttributeDeserializationFailed(_ attr: Swift.String, _ value: Swift.String) throws -> VoxAuth.XMLDeserializationError
  public var description: Swift.String {
    get
  }
}
extension Swift.String : VoxAuth.XMLElementDeserializable, VoxAuth.XMLAttributeDeserializable {
  public static func deserialize(_ element: VoxAuth.XMLElement) -> Swift.String
  public static func deserialize(_ attribute: VoxAuth.XMLAttribute) -> Swift.String
}
extension Swift.Int : VoxAuth.XMLElementDeserializable, VoxAuth.XMLAttributeDeserializable {
  public static func deserialize(_ element: VoxAuth.XMLElement) throws -> Swift.Int
  public static func deserialize(_ attribute: VoxAuth.XMLAttribute) throws -> Swift.Int
}
extension Swift.Double : VoxAuth.XMLElementDeserializable, VoxAuth.XMLAttributeDeserializable {
  public static func deserialize(_ element: VoxAuth.XMLElement) throws -> Swift.Double
  public static func deserialize(_ attribute: VoxAuth.XMLAttribute) throws -> Swift.Double
}
extension Swift.Float : VoxAuth.XMLElementDeserializable, VoxAuth.XMLAttributeDeserializable {
  public static func deserialize(_ element: VoxAuth.XMLElement) throws -> Swift.Float
  public static func deserialize(_ attribute: VoxAuth.XMLAttribute) throws -> Swift.Float
}
extension Swift.Bool : VoxAuth.XMLElementDeserializable, VoxAuth.XMLAttributeDeserializable {
  public static func deserialize(_ element: VoxAuth.XMLElement) throws -> Swift.Bool
  public static func deserialize(_ attribute: VoxAuth.XMLAttribute) throws -> Swift.Bool
}
public enum BlockMode {
  case ECB, CBC, PCBC, CFB, OFB, CTR
  public static func == (a: VoxAuth.BlockMode, b: VoxAuth.BlockMode) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class FirebaseManager {
  public static let shared: VoxAuth.FirebaseManager
  public static func configure(filePath: Swift.String)
  public static func logEvent(routerName: Swift.String)
  @objc deinit
}
public enum Bit : Swift.Int {
  case zero
  case one
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
@objc public enum VOXAUTHSDKReturnType : Swift.Int {
  case success = 1, noInternetConnection = 2, failure = 3, validation = 4
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public protocol RandomAccessCryptor : VoxAuth.Updatable {
  @discardableResult
  mutating func seek(to: Swift.Int) -> Swift.Bool
}
final public class SHA2 {
  public enum Variant : Swift.RawRepresentable {
    case sha224, sha256, sha384, sha512
    public var digestLength: Swift.Int {
      get
    }
    public var blockSize: Swift.Int {
      get
    }
    public typealias RawValue = Swift.Int
    public var rawValue: VoxAuth.SHA2.Variant.RawValue {
      get
    }
    public init?(rawValue: VoxAuth.SHA2.Variant.RawValue)
  }
  public init(variant: VoxAuth.SHA2.Variant)
  final public func calculate(for bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  @objc deinit
}
extension VoxAuth.SHA2 : VoxAuth.Updatable {
  final public func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = false) throws -> Swift.Array<Swift.UInt8>
}
extension VoxAuth.CSArrayType where Self.Element == Swift.UInt8 {
  public func toBase64() -> Swift.String?
  public init(base64: Swift.String)
}
public protocol Authenticator {
  func authenticate(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
}
public enum MD5 : VoxAuth.HashAlgorithm {
  public static var outputSize: Swift.UInt {
    get
  }
  public static var blockSize: Swift.UInt {
    get
  }
}
extension VoxAuth.MD5 : VoxAuth.MerkleDamgardConstructor {
  public static var initializationVector: [Swift.UInt32] {
    get
  }
  public static var rounds: Swift.UInt {
    get
  }
  public static func compress(_ data: Foundation.Data) -> [Swift.UInt32]
  public typealias BaseUnit = Swift.UInt32
}
final public class Rabbit {
  public enum Error : Swift.Error {
    case invalidKeyOrInitializationVector
    public static func == (a: VoxAuth.Rabbit.Error, b: VoxAuth.Rabbit.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public static let ivSize: Swift.Int
  public static let keySize: Swift.Int
  public static let blockSize: Swift.Int
  convenience public init(key: Swift.Array<Swift.UInt8>) throws
  public init(key: Swift.Array<Swift.UInt8>, iv: Swift.Array<Swift.UInt8>?) throws
  @objc deinit
}
extension VoxAuth.Rabbit : VoxAuth.Cipher {
  final public func encrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  final public func decrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
}
public typealias Hash = VoxAuth.Digest
public struct Digest {
  public static func md5(_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  public static func sha1(_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  public static func sha224(_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  public static func sha256(_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  public static func sha384(_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  public static func sha512(_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  public static func sha2(_ bytes: Swift.Array<Swift.UInt8>, variant: VoxAuth.SHA2.Variant) -> Swift.Array<Swift.UInt8>
  public static func sha3(_ bytes: Swift.Array<Swift.UInt8>, variant: VoxAuth.SHA3.Variant) -> Swift.Array<Swift.UInt8>
}
@objc public enum GetDeviceInfoCallback : Swift.Int {
  case OnSuccess
  case OnFail
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
final public class SHA1_CryptoSwift {
  public init()
  final public func calculate(for bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  @objc deinit
}
extension VoxAuth.SHA1_CryptoSwift : VoxAuth.Updatable {
  final public func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = false) throws -> Swift.Array<Swift.UInt8>
}
public enum SHA256 : VoxAuth.SHA2Variant {
  public typealias BaseUnit = Swift.UInt32
  public static var outputSize: Swift.UInt {
    get
  }
  public static var blockSize: Swift.UInt {
    get
  }
  public static var initializationVector: [VoxAuth.SHA256.BaseUnit] {
    get
  }
  public static var kConstants: [VoxAuth.SHA256.BaseUnit] {
    get
  }
  public static var s0ShiftAndRotateAmounts: (VoxAuth.SHA256.BaseUnit, VoxAuth.SHA256.BaseUnit, VoxAuth.SHA256.BaseUnit) {
    get
  }
  public static var s1ShiftAndRotateAmounts: (VoxAuth.SHA256.BaseUnit, VoxAuth.SHA256.BaseUnit, VoxAuth.SHA256.BaseUnit) {
    get
  }
  public static var S0ShiftAndRotateAmounts: (VoxAuth.SHA256.BaseUnit, VoxAuth.SHA256.BaseUnit, VoxAuth.SHA256.BaseUnit) {
    get
  }
  public static var S1ShiftAndRotateAmounts: (VoxAuth.SHA256.BaseUnit, VoxAuth.SHA256.BaseUnit, VoxAuth.SHA256.BaseUnit) {
    get
  }
}
extension VoxAuth.AES {
  convenience public init(key: Swift.String, iv: Swift.String, blockMode: VoxAuth.BlockMode = .CBC, padding: VoxAuth.Padding = .pkcs7) throws
}
final public class ChaCha20 {
  public enum Error : Swift.Error {
    case invalidKeyOrInitializationVector
    public static func == (a: VoxAuth.ChaCha20.Error, b: VoxAuth.ChaCha20.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public static let blockSize: Swift.Int
  public init(key: Swift.Array<Swift.UInt8>, iv nonce: Swift.Array<Swift.UInt8>) throws
  @objc deinit
}
extension VoxAuth.ChaCha20 : VoxAuth.Cipher {
  final public func encrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  final public func decrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
}
extension VoxAuth.ChaCha20 {
  public struct Encryptor : VoxAuth.Updatable {
    public mutating func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = false) throws -> Swift.Array<Swift.UInt8>
  }
}
extension VoxAuth.ChaCha20 {
  public struct Decryptor : VoxAuth.Updatable {
    public mutating func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = true) throws -> Swift.Array<Swift.UInt8>
  }
}
extension VoxAuth.ChaCha20 : VoxAuth.Cryptors {
  final public func makeEncryptor() -> VoxAuth.ChaCha20.Encryptor
  final public func makeDecryptor() -> VoxAuth.ChaCha20.Decryptor
  public typealias DecryptorType = VoxAuth.ChaCha20.Decryptor
  public typealias EncryptorType = VoxAuth.ChaCha20.Encryptor
}
@objc public enum OTPAlgorithm : Swift.Int {
  case HmacSHA1
  case HmacSHA256
  case HmacSHA512
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public enum Algorithm {
  case md5, sha1, sha224, sha256, sha384, sha512
  public var digestLength: Swift.Int {
    get
  }
  public static func == (a: VoxAuth.Algorithm, b: VoxAuth.Algorithm) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public protocol Hashable {
  associatedtype Hash
  func digest(_ algorithm: VoxAuth.Algorithm, key: Swift.String?) -> Self.Hash
  var md5: Self.Hash { get }
  var sha1: Self.Hash { get }
  var sha224: Self.Hash { get }
  var sha256: Self.Hash { get }
  var sha384: Self.Hash { get }
  var sha512: Self.Hash { get }
}
extension VoxAuth.Hashable {
  public var md5: Self.Hash {
    get
  }
  public var sha1: Self.Hash {
    get
  }
  public var sha224: Self.Hash {
    get
  }
  public var sha256: Self.Hash {
    get
  }
  public var sha384: Self.Hash {
    get
  }
  public var sha512: Self.Hash {
    get
  }
}
extension Swift.String : VoxAuth.Hashable {
  public func digest(_ algorithm: VoxAuth.Algorithm) -> Swift.String
  public func digest(_ algorithm: VoxAuth.Algorithm, key: Swift.String?) -> Swift.String
  public func digest(_ algorithm: VoxAuth.Algorithm, key: Foundation.Data?) -> Swift.String
  public typealias Hash = Swift.String
}
extension Foundation.Data : VoxAuth.Hashable {
  public func digest(_ algorithm: VoxAuth.Algorithm) -> Foundation.Data
  public func digest(_ algorithm: VoxAuth.Algorithm, key: Swift.String?) -> Foundation.Data
  public func digest(_ algorithm: VoxAuth.Algorithm, key: Foundation.Data?) -> Foundation.Data
  public typealias Hash = Foundation.Data
}
extension VoxAuth.PKCS5 {
  public struct PBKDF2 {
    public enum Error : Swift.Error {
      case invalidInput
      case derivedKeyTooLong
      public static func == (a: VoxAuth.PKCS5.PBKDF2.Error, b: VoxAuth.PKCS5.PBKDF2.Error) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    public init(password: Swift.Array<Swift.UInt8>, salt: Swift.Array<Swift.UInt8>, iterations: Swift.Int = 4096, keyLength: Swift.Int? = nil, variant: VoxAuth.HMAC.Variant = .sha256) throws
    public func calculate() throws -> Swift.Array<Swift.UInt8>
  }
}
@objc(VOXAUTHSDKClient) public class VOXAUTHSDKClient : ObjectiveC.NSObject {
  @objc public init(webServiceUrl: Swift.String = "http://web.voxdatati.com.br/WsAuth", channelName: Swift.String = "AuthSDK_IOS", password: Swift.String!, clientId: Swift.String!, nicknameDevice: Swift.String!)
  @objc(GetDeviceID:) public static func getDeviceID() throws -> Swift.String
  @objc public static func getVersion() -> Swift.String!
  @objc public func hasNetworkConnection() -> Swift.Bool
  @objc public func available() -> Swift.Bool
  public func getConnectionType() -> VoxAuth.Reachability.Connection
  @objc public func syncDate() throws
  @objc(GetDeviceInfo:) public func getDeviceInfo() throws -> VoxAuth.DeviceInfo
  @objc public func getDeviceInfoWithCallBack(callback: (VoxAuth.GetDeviceInfoCallback, VoxAuth.DeviceInfo?, VoxAuth.GenericException?) -> ())
  @objc public func getDeviceIP() -> Swift.String
  @objc public func getDeviceMacAdress() -> Swift.String
  @objc public func registerForRemoteNotifications(apnsToken: Foundation.Data!)
  @discardableResult
  public func getUnixTime() throws -> Swift.Int64
  public func verifyClientAccess(info: VoxAuth.DeviceInfo, _ callback: @escaping (VoxAuth.VOXAUTHSDKReturnType, Swift.String) -> ())
  @objc(verifyClientAccess:withError:) public func verifyClientAccess(info: VoxAuth.DeviceInfo) throws -> VoxAuth.VOXAUTHSDKReturn
  @objc(getAuthenticationMethods:withError:) public func getAuthenticationMethods(transaction: VoxAuth.Transaction) throws -> [VoxAuth.AuthenticationMethod]
  @objc(getAuthenticationMethodsMobile::withError:) public func getAuthenticationMethodsMobile(info: VoxAuth.DeviceInfo, transaction: VoxAuth.Transaction) throws -> [VoxAuth.AuthenticationMethod]
  @objc(syncAuthenticationMethodsConfigs:withError:) public func syncAuthenticationMethodsConfigs(info: VoxAuth.DeviceInfo) throws -> [VoxAuth.AuthenticationMethod]
  @objc(getAuthenticationMethodsConfigs:withError:) public func getAuthenticationMethodsConfigs(info: VoxAuth.DeviceInfo) throws -> [VoxAuth.AuthenticationMethod]
  @objc(insertMobileToken:withError:) public func insertMobileToken(info: VoxAuth.DeviceInfo) throws -> VoxAuth.AuthenticationMethod
  @objc(getMobileToken::::withError:) public func getMobileToken(algorithm: VoxAuth.OTPAlgorithm, secret: Swift.String, size: Swift.String, interval: Swift.String) throws -> Swift.String
  @objc(MTokenAuthentication:::withError:) public func MTokenAuthentication(transaction: VoxAuth.Transaction, idAuthenticationMethod: Swift.Int64, mtoken: Swift.String) throws -> VoxAuth.Return
  @objc(validateAuthentication::withError:) public func validateAuthentication(authSignature: Swift.String, passwordReceived: Swift.String) throws -> VoxAuth.Return
  @objc(ResponseAuthentication:withError:) public func ResponseAuthentication(authSignature: Swift.String) throws -> VoxAuth.Return
  @objc(InsertQRCode:withError:) public func InsertQRCode(info: VoxAuth.DeviceInfo) throws -> VoxAuth.AuthenticationMethod
  @objc(QrCodeAuthentication::withError:) public func QrCodeAuthentication(transaction: VoxAuth.Transaction, idAuthenticationMethod: Swift.Int64) throws -> VoxAuth.Return
  @objc(QrCodeConfirmation::withError:) public func QrCodeConfirmation(code: Swift.String, idAuthenticationMethod: Swift.Int64) throws -> VoxAuth.Return
  @objc(EmailAuthentication:::withError:) public func EmailAuthentication(transaction: VoxAuth.Transaction, idAuthenticationMethod: Swift.Int64, email: Swift.String) throws -> VoxAuth.Return
  @objc(InsertPushAction:withError:) public func InsertPushAction(info: VoxAuth.DeviceInfo) throws -> VoxAuth.VOXAUTHSDKReturnAuthenticationMethod
  @objc(ReversePushAuthentication::withError:) public func ReversePushAuthentication(transaction: VoxAuth.Transaction, idAuthenticationMethod: Swift.Int64) throws -> VoxAuth.Return
  @objc(ReversePushRegisterAnswer:::withError:) public func ReversePushRegisterAnswer(authenticationID: Swift.Int64, idAuthenticationMethod: Swift.Int64, answer: Swift.String) throws -> VoxAuth.Return
  @objc(InsertPushPassword:withError:) public func InsertPushPassword(info: VoxAuth.DeviceInfo) throws -> VoxAuth.AuthenticationMethod
  @objc(PushAuthentication::withError:) public func PushAuthentication(transaction: VoxAuth.Transaction, idAuthenticationMethod: Swift.Int64) throws -> VoxAuth.Return
  @objc(InsertSpeechRecognition:withError:) public func InsertSpeechRecognition(info: VoxAuth.DeviceInfo) throws -> VoxAuth.AuthenticationMethod
  @objc(InsertFingerprintBiometry:withError:) public func InsertFingerprintBiometry(info: VoxAuth.DeviceInfo) throws -> VoxAuth.AuthenticationMethod
  @objc(FingerprintAuthentication::withError:) public func FingerprintAuthentication(transaction: VoxAuth.Transaction, idAuthenticationMethod: Swift.Int64) throws -> VoxAuth.Return
  @objc(InsertFacialBiometry::withError:) public func InsertFacialBiometry(info: VoxAuth.DeviceInfo, image: Swift.String) throws -> VoxAuth.AuthenticationMethod
  @objc(SMSAuthentication:::withError:) public func SMSAuthentication(transaction: VoxAuth.Transaction, idAuthenticationMethod: Swift.Int64, telephone: Swift.String) throws -> VoxAuth.Return
  @objc(ReverseSMSAuthentication:::withError:) public func ReverseSMSAuthentication(transaction: VoxAuth.Transaction, idAuthenticationMethod: Swift.Int64, telephone: Swift.String) throws -> VoxAuth.Return
  @objc(URAAuthentication:::withError:) public func URAAuthentication(transaction: VoxAuth.Transaction, idAuthenticationMethod: Swift.Int64, telephone: Swift.String) throws -> VoxAuth.Return
  @objc deinit
}
extension VoxAuth.VOXAUTHSDKClient {
  @objc dynamic public func set(host text: Swift.String)
  @objc dynamic public func set(key text: Swift.String)
  @objc dynamic public func set(clientId text: Swift.String)
  public func getClockDiference() -> Swift.Int64
}
extension VoxAuth.PKCS5 {
  public struct PBKDF1 {
    public enum Error : Swift.Error {
      case invalidInput
      case derivedKeyTooLong
      public static func == (a: VoxAuth.PKCS5.PBKDF1.Error, b: VoxAuth.PKCS5.PBKDF1.Error) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    public enum Variant {
      case md5, sha1
      public static func == (a: VoxAuth.PKCS5.PBKDF1.Variant, b: VoxAuth.PKCS5.PBKDF1.Variant) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    public init(password: Swift.Array<Swift.UInt8>, salt: Swift.Array<Swift.UInt8>, variant: VoxAuth.PKCS5.PBKDF1.Variant = .sha1, iterations: Swift.Int = 4096, keyLength: Swift.Int? = nil) throws
    public func calculate() -> Swift.Array<Swift.UInt8>
  }
}
@_inheritsConvenienceInitializers @objc(Transaction) public class Transaction : ObjectiveC.NSObject {
  @objc override dynamic public init()
  @objc public init(ClientName: Swift.String, ClientFirstName: Swift.String, IP: Swift.String, MacAddress: Swift.String)
  @objc public var Code: Swift.String
  @objc public var Date: Foundation.Date
  @objc public var Value: Swift.Double
  @objc public var Info3: Swift.String
  @objc public var Info4: Swift.String
  @objc public var Info5: Swift.String
  @objc public var Info6: Swift.String
  @objc public var Info7: Swift.String
  @objc public var Info8: Swift.String
  @objc public func set(ClientName text: Swift.String)
  @objc public func set(ClientFirstName text: Swift.String)
  @objc public func set(IP text: Swift.String)
  @objc public func set(MacAddress text: Swift.String)
  @objc deinit
}
@_hasMissingDesignatedInitializers public class SWXMLHashOptions {
  public var shouldProcessLazily: Swift.Bool
  public var shouldProcessNamespaces: Swift.Bool
  public var caseInsensitive: Swift.Bool
  public var encoding: Swift.String.Encoding
  public var userInfo: [Swift.CodingUserInfoKey : Any]
  @objc deinit
}
@_hasMissingDesignatedInitializers public class SWXMLHash {
  public class func config(_ configAction: (VoxAuth.SWXMLHashOptions) -> Swift.Void) -> VoxAuth.SWXMLHash
  public func parse(_ xml: Swift.String) -> VoxAuth.XMLIndexer
  public func parse(_ data: Foundation.Data) -> VoxAuth.XMLIndexer
  public class func parse(_ xml: Swift.String) -> VoxAuth.XMLIndexer
  public class func parse(_ data: Foundation.Data) -> VoxAuth.XMLIndexer
  public class func lazy(_ xml: Swift.String) -> VoxAuth.XMLIndexer
  public class func lazy(_ data: Foundation.Data) -> VoxAuth.XMLIndexer
  @objc deinit
}
@_hasMissingDesignatedInitializers public class IndexOp {
  @objc deinit
}
@_hasMissingDesignatedInitializers public class IndexOps {
  @objc deinit
}
public enum IndexingError : Swift.Error {
  case attribute(attr: Swift.String)
  case attributeValue(attr: Swift.String, value: Swift.String)
  case key(key: Swift.String)
  case index(idx: Swift.Int)
  case initialize(instance: Swift.AnyObject)
  case encoding
  case error
  @available(*, unavailable, renamed: "attribute(attr:)")
  public static func Attribute(attr: Swift.String) -> VoxAuth.IndexingError
  @available(*, unavailable, renamed: "attributeValue(attr:value:)")
  public static func AttributeValue(attr: Swift.String, value: Swift.String) -> VoxAuth.IndexingError
  @available(*, unavailable, renamed: "key(key:)")
  public static func Key(key: Swift.String) -> VoxAuth.IndexingError
  @available(*, unavailable, renamed: "index(idx:)")
  public static func Index(idx: Swift.Int) -> VoxAuth.IndexingError
  @available(*, unavailable, renamed: "initialize(instance:)")
  public static func Init(instance: Swift.AnyObject) -> VoxAuth.IndexingError
  @available(*, unavailable, renamed: "error")
  public static var Error: VoxAuth.IndexingError {
    get
  }
}
public enum XMLIndexer {
  case element(VoxAuth.XMLElement)
  case list([VoxAuth.XMLElement])
  case stream(VoxAuth.IndexOps)
  case xmlError(VoxAuth.IndexingError)
  @available(*, unavailable, renamed: "element(_:)")
  public static func Element(_: VoxAuth.XMLElement) -> VoxAuth.XMLIndexer
  @available(*, unavailable, renamed: "list(_:)")
  public static func List(_: [VoxAuth.XMLElement]) -> VoxAuth.XMLIndexer
  @available(*, unavailable, renamed: "stream(_:)")
  public static func Stream(_: VoxAuth.IndexOps) -> VoxAuth.XMLIndexer
  @available(*, unavailable, renamed: "xmlError(_:)")
  public static func XMLError(_: VoxAuth.IndexingError) -> VoxAuth.XMLIndexer
  @available(*, unavailable, renamed: "withAttribute(_:_:)")
  public static func withAttr(_ attr: Swift.String, _ value: Swift.String) throws -> VoxAuth.XMLIndexer
  public var element: VoxAuth.XMLElement? {
    get
  }
  public var all: [VoxAuth.XMLIndexer] {
    get
  }
  public var children: [VoxAuth.XMLIndexer] {
    get
  }
  @available(*, unavailable, renamed: "filterChildren(_:)")
  public func filter(_ included: (_ elem: VoxAuth.XMLElement, _ index: Swift.Int) -> Swift.Bool) -> VoxAuth.XMLIndexer
  public func filterChildren(_ included: (_ elem: VoxAuth.XMLElement, _ index: Swift.Int) -> Swift.Bool) -> VoxAuth.XMLIndexer
  public func filterAll(_ included: (_ elem: VoxAuth.XMLElement, _ index: Swift.Int) -> Swift.Bool) -> VoxAuth.XMLIndexer
  public var userInfo: [Swift.CodingUserInfoKey : Any] {
    get
  }
  public func withAttribute(_ attr: Swift.String, _ value: Swift.String) throws -> VoxAuth.XMLIndexer
  public init(_ rawObject: Swift.AnyObject) throws
  public init(_ elem: VoxAuth.XMLElement)
  public func byKey(_ key: Swift.String) throws -> VoxAuth.XMLIndexer
  public subscript(key: Swift.String) -> VoxAuth.XMLIndexer {
    get
  }
  public func byIndex(_ index: Swift.Int) throws -> VoxAuth.XMLIndexer
  public subscript(index: Swift.Int) -> VoxAuth.XMLIndexer {
    get
  }
}
extension VoxAuth.XMLIndexer : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension VoxAuth.IndexingError : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
public protocol XMLContent : Swift.CustomStringConvertible {
}
@_hasMissingDesignatedInitializers public class TextElement : VoxAuth.XMLContent {
  final public let text: Swift.String
  @objc deinit
}
public struct XMLAttribute {
  public let name: Swift.String
  public let text: Swift.String
}
@_hasMissingDesignatedInitializers public class XMLElement : VoxAuth.XMLContent {
  final public let name: Swift.String
  public var caseInsensitive: Swift.Bool {
    get
  }
  public var allAttributes: [Swift.String : VoxAuth.XMLAttribute]
  public func attribute(by name: Swift.String) -> VoxAuth.XMLAttribute?
  public var text: Swift.String {
    get
  }
  public var recursiveText: Swift.String {
    get
  }
  public var children: [any VoxAuth.XMLContent]
  @objc deinit
}
extension VoxAuth.TextElement : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension VoxAuth.XMLAttribute : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension VoxAuth.XMLElement : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension VoxAuth.SWXMLHash {
  public typealias XMLElement = VoxAuth.SWXMLHashXMLElement
}
public typealias SWXMLHashXMLElement = VoxAuth.XMLElement
extension Foundation.Data {
  public func checksum() -> Swift.UInt16
  public func md5() -> Foundation.Data
  public func sha1() -> Foundation.Data
  public func sha224() -> Foundation.Data
  public func sha256() -> Foundation.Data
  public func sha384() -> Foundation.Data
  public func sha512() -> Foundation.Data
  public func sha3(_ variant: VoxAuth.SHA3.Variant) -> Foundation.Data
  public func crc32(seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Foundation.Data
  public func crc16(seed: Swift.UInt16? = nil) -> Foundation.Data
  public func encrypt(cipher: any VoxAuth.Cipher) throws -> Foundation.Data
  public func decrypt(cipher: any VoxAuth.Cipher) throws -> Foundation.Data
  public func authenticate(with authenticator: any VoxAuth.Authenticator) throws -> Foundation.Data
}
extension Foundation.Data {
  public var bytes: Swift.Array<Swift.UInt8> {
    get
  }
  public func toHexString() -> Swift.String
}
public protocol PaddingProtocol {
  func add(to: Swift.Array<Swift.UInt8>, blockSize: Swift.Int) -> Swift.Array<Swift.UInt8>
  func remove(from: Swift.Array<Swift.UInt8>, blockSize: Swift.Int?) -> Swift.Array<Swift.UInt8>
}
public enum Padding : VoxAuth.PaddingProtocol {
  case noPadding, zeroPadding, pkcs7, pkcs5
  public func add(to: Swift.Array<Swift.UInt8>, blockSize: Swift.Int) -> Swift.Array<Swift.UInt8>
  public func remove(from: Swift.Array<Swift.UInt8>, blockSize: Swift.Int?) -> Swift.Array<Swift.UInt8>
  public static func == (a: VoxAuth.Padding, b: VoxAuth.Padding) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension VoxAuth.Blowfish {
  convenience public init(key: Swift.String, iv: Swift.String, blockMode: VoxAuth.BlockMode = .CBC, padding: VoxAuth.Padding = .pkcs7) throws
}
public protocol CSArrayType : Swift.RangeReplaceableCollection {
  func cs_arrayValue() -> [Self.Iterator.Element]
}
extension Swift.Array : VoxAuth.CSArrayType {
  public func cs_arrayValue() -> [Swift.Array<Element>.Iterator.Element]
}
extension VoxAuth.CSArrayType where Self.Element == Swift.UInt8 {
  public func toHexString() -> Swift.String
}
extension VoxAuth.CSArrayType where Self.Element == Swift.UInt8 {
  public func md5() -> [Self.Iterator.Element]
  public func sha1() -> [Self.Iterator.Element]
  public func sha224() -> [Self.Iterator.Element]
  public func sha256() -> [Self.Iterator.Element]
  public func sha384() -> [Self.Iterator.Element]
  public func sha512() -> [Self.Iterator.Element]
  public func sha2(_ variant: VoxAuth.SHA2.Variant) -> [Self.Iterator.Element]
  public func sha3(_ variant: VoxAuth.SHA3.Variant) -> [Self.Iterator.Element]
  public func crc32(seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Swift.UInt32
  public func crc16(seed: Swift.UInt16? = nil) -> Swift.UInt16
  public func encrypt(cipher: any VoxAuth.Cipher) throws -> [Self.Iterator.Element]
  public func decrypt(cipher: any VoxAuth.Cipher) throws -> [Self.Iterator.Element]
  public func authenticate<A>(with authenticator: A) throws -> [Self.Iterator.Element] where A : VoxAuth.Authenticator
}
public enum Endianess {
  case bigEndian
  case littleEndian
  public static func == (a: VoxAuth.Endianess, b: VoxAuth.Endianess) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public protocol MerkleDamgardConstructor : VoxAuth.HashAlgorithm {
  associatedtype BaseUnit : Swift.FixedWidthInteger, Swift.UnsignedInteger
  static var endianess: VoxAuth.Endianess { get }
  static var initializationVector: [Self.BaseUnit] { get }
  static var rounds: Swift.UInt { get }
  static var lengthPaddingSize: Swift.UInt { get }
  static func applyPadding(to message: Foundation.Data) -> Foundation.Data
  static func compress(_ data: Foundation.Data) -> [Self.BaseUnit]
  static func finalize(vector: [Self.BaseUnit]) -> Foundation.Data
}
extension VoxAuth.MerkleDamgardConstructor {
  public static var endianess: VoxAuth.Endianess {
    get
  }
  public static var lengthPaddingSize: Swift.UInt {
    get
  }
  public static func applyPadding(to message: Foundation.Data) -> Foundation.Data
  public static func finalize(vector: [Self.BaseUnit]) -> Foundation.Data
  public static func digest(_ message: Foundation.Data) -> Foundation.Data
}
public enum SHA384 : VoxAuth.SHA2Variant {
  public static var outputSize: Swift.UInt {
    get
  }
  public static var blockSize: Swift.UInt {
    get
  }
  public static var initializationVector: [Swift.UInt64] {
    get
  }
  public static var kConstants: [Swift.UInt64] {
    get
  }
  public static var s0ShiftAndRotateAmounts: (Swift.UInt64, Swift.UInt64, Swift.UInt64) {
    get
  }
  public static var s1ShiftAndRotateAmounts: (Swift.UInt64, Swift.UInt64, Swift.UInt64) {
    get
  }
  public static var S0ShiftAndRotateAmounts: (Swift.UInt64, Swift.UInt64, Swift.UInt64) {
    get
  }
  public static var S1ShiftAndRotateAmounts: (Swift.UInt64, Swift.UInt64, Swift.UInt64) {
    get
  }
  public static func finalize(vector: [Swift.UInt64]) -> Foundation.Data
  public typealias BaseUnit = Swift.UInt64
}
public enum SHA224 : VoxAuth.SHA2Variant {
  public static var outputSize: Swift.UInt {
    get
  }
  public static var blockSize: Swift.UInt {
    get
  }
  public static var kConstants: [Swift.UInt32] {
    get
  }
  public static var s0ShiftAndRotateAmounts: (Swift.UInt32, Swift.UInt32, Swift.UInt32) {
    get
  }
  public static var s1ShiftAndRotateAmounts: (Swift.UInt32, Swift.UInt32, Swift.UInt32) {
    get
  }
  public static var S0ShiftAndRotateAmounts: (Swift.UInt32, Swift.UInt32, Swift.UInt32) {
    get
  }
  public static var S1ShiftAndRotateAmounts: (Swift.UInt32, Swift.UInt32, Swift.UInt32) {
    get
  }
  public static var initializationVector: [Swift.UInt32] {
    get
  }
  public static func finalize(vector: [Swift.UInt32]) -> Foundation.Data
  public typealias BaseUnit = Swift.UInt32
}
extension Swift.String : Foundation.LocalizedError {
  public var errorDescription: Swift.String? {
    get
  }
  public var bytes: Swift.Array<Swift.UInt8> {
    get
  }
  public func md5() -> Swift.String
  public func sha1() -> Swift.String
  public func sha224() -> Swift.String
  public func sha256() -> Swift.String
  public func sha384() -> Swift.String
  public func sha512() -> Swift.String
  public func sha3(_ variant: VoxAuth.SHA3.Variant) -> Swift.String
  public func crc32(seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Swift.String
  public func crc16(seed: Swift.UInt16? = nil) -> Swift.String
  public func encrypt(cipher: any VoxAuth.Cipher) throws -> Swift.String
  public func encryptToBase64(cipher: any VoxAuth.Cipher) throws -> Swift.String?
  public func authenticate<A>(with authenticator: A) throws -> Swift.String where A : VoxAuth.Authenticator
}
public enum PKCS7 {
}
public enum Base32 {
  public static func encode(_ data: Foundation.Data) -> Swift.String
  public static func decode(_ string: Swift.String) throws -> Foundation.Data
  public static func character(for value: Swift.UInt8) -> Swift.Character?
  public static func value(for character: Swift.Character) -> Swift.UInt8?
}
public enum Base32DecodingError : Swift.Error {
  case invalidCharacter(character: Swift.Character)
}
@objc public enum CodReturnType : Swift.Int {
  case UNKNOWN_COD_RETURN = 0
  case SUCCESS = 1
  case FAIL = 2
  case WAITING = 3
  case TIMEOUT = 4
  case BUSINESS_ERROR = 5
  case APLICATION_ERROR = 6
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
@_inheritsConvenienceInitializers @objc(Return) public class Return : ObjectiveC.NSObject {
  @objc public var CodReturn: Swift.Int
  @objc public var Data: Swift.String
  @objc public var MessageReturn: Swift.String
  @objc public var OperationDate: Swift.String
  @objc public var BlockDate: Swift.String
  @objc public var TimeOutResponse: Swift.Int
  @objc public var AnotherAuthentication: Swift.Bool
  @objc public var SameAuthentication: Swift.Bool
  @objc public var AuthenticationSignature: Swift.String
  @objc public func getReturnType() -> VoxAuth.CodReturnType
  @objc override dynamic public init()
  @objc deinit
}
final public class AES {
  public enum Error : Swift.Error {
    case dataPaddingRequired
    case invalidKeyOrInitializationVector
    case invalidInitializationVector
    case invalidData
    public static func == (a: VoxAuth.AES.Error, b: VoxAuth.AES.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum Variant : Swift.Int {
    case aes128, aes192, aes256
    public init?(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
  public static let blockSize: Swift.Int
  final public var variant: VoxAuth.AES.Variant {
    get
  }
  public init(key: Swift.Array<Swift.UInt8>, iv: Swift.Array<Swift.UInt8>? = nil, blockMode: VoxAuth.BlockMode = .CBC, padding: VoxAuth.Padding = .pkcs7) throws
  @objc deinit
}
extension VoxAuth.AES {
  public struct Encryptor : VoxAuth.Updatable {
    public mutating func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = false) throws -> Swift.Array<Swift.UInt8>
  }
}
extension VoxAuth.AES {
  public struct Decryptor : VoxAuth.RandomAccessCryptor {
    public mutating func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = false) throws -> Swift.Array<Swift.UInt8>
    @discardableResult
    public mutating func seek(to position: Swift.Int) -> Swift.Bool
  }
}
extension VoxAuth.AES : VoxAuth.Cryptors {
  final public func makeEncryptor() -> VoxAuth.AES.Encryptor
  final public func makeDecryptor() -> VoxAuth.AES.Decryptor
  public typealias DecryptorType = VoxAuth.AES.Decryptor
  public typealias EncryptorType = VoxAuth.AES.Encryptor
}
extension VoxAuth.AES : VoxAuth.Cipher {
  final public func encrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  final public func decrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
}
final public class MD5_CryptoSwift {
  public init()
  final public func calculate(for bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  @objc deinit
}
extension VoxAuth.MD5_CryptoSwift : VoxAuth.Updatable {
  final public func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = false) throws -> Swift.Array<Swift.UInt8>
}
extension VoxAuth.ChaCha20 {
  convenience public init(key: Swift.String, iv: Swift.String) throws
}
@objc(VOXAUTHSDKReturn) public class VOXAUTHSDKReturn : ObjectiveC.NSObject {
  @objc public var status: VoxAuth.VOXAUTHSDKReturnType
  @objc public var mensagem: Swift.String
  @objc public init(status: VoxAuth.VOXAUTHSDKReturnType, mensagem: Swift.String)
  @objc deinit
}
@_inheritsConvenienceInitializers @objc(VOXAUTHSDKReturnAuthenticationMethod) public class VOXAUTHSDKReturnAuthenticationMethod : VoxAuth.VOXAUTHSDKReturn {
  @objc public var authenticationMethod: VoxAuth.AuthenticationMethod?
  @objc override public init(status: VoxAuth.VOXAUTHSDKReturnType, mensagem: Swift.String)
  @objc public init(status: VoxAuth.VOXAUTHSDKReturnType, mensagem: Swift.String, auth: VoxAuth.AuthenticationMethod?)
  @objc deinit
}
@_inheritsConvenienceInitializers @objc(VOXAUTHSDKReturnAuthenticationsMethod) public class VOXAUTHSDKReturnAuthenticationsMethod : VoxAuth.VOXAUTHSDKReturn {
  @objc public var authenticationsMethod: [VoxAuth.AuthenticationMethod]?
  @objc override public init(status: VoxAuth.VOXAUTHSDKReturnType, mensagem: Swift.String)
  @objc public init(status: VoxAuth.VOXAUTHSDKReturnType, mensagem: Swift.String, auths: [VoxAuth.AuthenticationMethod]?)
  @objc deinit
}
@_inheritsConvenienceInitializers @objc(VOXAUTHSDKReturnToken) public class VOXAUTHSDKReturnToken : VoxAuth.VOXAUTHSDKReturn {
  @objc public var token: Swift.String?
  @objc public var seconds: Swift.Float
  @objc override public init(status: VoxAuth.VOXAUTHSDKReturnType, mensagem: Swift.String)
  @objc public init(status: VoxAuth.VOXAUTHSDKReturnType, mensagem: Swift.String, token: Swift.String?, seconds: Swift.Float)
  @objc deinit
}
@_inheritsConvenienceInitializers @objc(VOXAUTHSDKReturnService) public class VOXAUTHSDKReturnService : VoxAuth.VOXAUTHSDKReturn {
  @objc public var retorno: VoxAuth.Return?
  @objc override public init(status: VoxAuth.VOXAUTHSDKReturnType, mensagem: Swift.String)
  @objc public init(status: VoxAuth.VOXAUTHSDKReturnType, mensagem: Swift.String, retorno: VoxAuth.Return?)
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class Checksum {
  @objc deinit
}
extension VoxAuth.Checksum {
  public static func crc32(_ message: Swift.Array<Swift.UInt8>, seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Swift.UInt32
  public static func crc16(_ message: Swift.Array<Swift.UInt8>, seed: Swift.UInt16? = nil) -> Swift.UInt16
}
public func HMAC_kit(key: Foundation.Data, message: Foundation.Data, hashFunction: VoxAuth.HashFunction) -> Foundation.Data
final public class Blowfish {
  public enum Error : Swift.Error {
    case dataPaddingRequired
    case invalidKeyOrInitializationVector
    case invalidInitializationVector
    public static func == (a: VoxAuth.Blowfish.Error, b: VoxAuth.Blowfish.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public static let blockSize: Swift.Int
  public init(key: Swift.Array<Swift.UInt8>, iv: Swift.Array<Swift.UInt8>? = nil, blockMode: VoxAuth.BlockMode = .CBC, padding: VoxAuth.Padding) throws
  @objc deinit
}
extension VoxAuth.Blowfish : VoxAuth.Cipher {
  final public func encrypt<C>(_ bytes: C) throws -> Swift.Array<Swift.UInt8> where C : Swift.Collection, C.Element == Swift.UInt8, C.Index == Swift.Int
  final public func decrypt<C>(_ bytes: C) throws -> Swift.Array<Swift.UInt8> where C : Swift.Collection, C.Element == Swift.UInt8, C.Index == Swift.Int
}
public enum HOTPError : Swift.Error {
  case InvalidDigits
  public static func == (a: VoxAuth.HOTPError, b: VoxAuth.HOTPError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension VoxAuth.Rabbit {
  convenience public init(key: Swift.String) throws
  convenience public init(key: Swift.String, iv: Swift.String) throws
}
extension Swift.String {
  public func decryptBase64ToString(cipher: any VoxAuth.Cipher) throws -> Swift.String
  public func decryptBase64(cipher: any VoxAuth.Cipher) throws -> Swift.Array<Swift.UInt8>
}
final public class HMAC : VoxAuth.Authenticator {
  public enum Error : Swift.Error {
    case authenticateError
    case invalidInput
    public static func == (a: VoxAuth.HMAC.Error, b: VoxAuth.HMAC.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum Variant {
    case sha1, sha256, sha384, sha512, md5
    public static func == (a: VoxAuth.HMAC.Variant, b: VoxAuth.HMAC.Variant) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public init(key: Swift.Array<Swift.UInt8>, variant: VoxAuth.HMAC.Variant = .md5)
  final public func authenticate(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  @objc deinit
}
extension Swift.Array {
  public func chunks(size chunksize: Swift.Int) -> Swift.Array<Swift.Array<Element>>
}
extension Swift.Array where Element == Swift.UInt8 {
  public init(hex: Swift.String)
}
public protocol Updatable {
  mutating func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool) throws -> Swift.Array<Swift.UInt8>
  mutating func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool, output: (_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Void) throws
  mutating func finish(withBytes bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  mutating func finish(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, output: (_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Void) throws
}
extension VoxAuth.Updatable {
  public mutating func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = false, output: (_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Void) throws
  public mutating func finish(withBytes bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  public mutating func finish() throws -> Swift.Array<Swift.UInt8>
  public mutating func finish(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, output: (_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Void) throws
  public mutating func finish(output: (Swift.Array<Swift.UInt8>) -> Swift.Void) throws
}
extension VoxAuth.Updatable {
  public mutating func update(withBytes bytes: Swift.Array<Swift.UInt8>, isLast: Swift.Bool = false) throws -> Swift.Array<Swift.UInt8>
  public mutating func update(withBytes bytes: Swift.Array<Swift.UInt8>, isLast: Swift.Bool = false, output: (_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Void) throws
  public mutating func finish(withBytes bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  public mutating func finish(withBytes bytes: Swift.Array<Swift.UInt8>, output: (_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Void) throws
}
public enum SHA512 : VoxAuth.SHA2Variant {
  public static var outputSize: Swift.UInt {
    get
  }
  public static var blockSize: Swift.UInt {
    get
  }
  public static var initializationVector: [Swift.UInt64] {
    get
  }
  public static var kConstants: [Swift.UInt64] {
    get
  }
  public static var s0ShiftAndRotateAmounts: (Swift.UInt64, Swift.UInt64, Swift.UInt64) {
    get
  }
  public static var s1ShiftAndRotateAmounts: (Swift.UInt64, Swift.UInt64, Swift.UInt64) {
    get
  }
  public static var S0ShiftAndRotateAmounts: (Swift.UInt64, Swift.UInt64, Swift.UInt64) {
    get
  }
  public static var S1ShiftAndRotateAmounts: (Swift.UInt64, Swift.UInt64, Swift.UInt64) {
    get
  }
  public typealias BaseUnit = Swift.UInt64
}
public class OCRA {
  public init?(ocraSuite: Swift.String, seed: Swift.String, counter: Swift.String, question: Swift.String, password: Swift.String, sessionInformation: Swift.String, timeStamp: Swift.String)
  public func generate() -> Swift.String?
  @objc deinit
}
public enum PKCS5 {
}
public protocol Cryptors : AnyObject {
  associatedtype EncryptorType : VoxAuth.Updatable
  associatedtype DecryptorType : VoxAuth.Updatable
  func makeEncryptor() -> Self.EncryptorType
  func makeDecryptor() -> Self.DecryptorType
  static func randomIV(_ blockSize: Swift.Int) -> Swift.Array<Swift.UInt8>
}
extension VoxAuth.Cryptors {
  public static func randomIV(_ blockSize: Swift.Int) -> Swift.Array<Swift.UInt8>
}
extension UIKit.UIDevice {
  @_Concurrency.MainActor(unsafe) public var identifier: Swift.String {
    get
  }
  @_Concurrency.MainActor(unsafe) public var modelName: Swift.String {
    get
  }
}
@available(*, unavailable, renamed: "Conection")
extension VoxAuth.Reachability.NetworkStatus : Swift.Equatable {}
@available(*, unavailable, renamed: "Conection")
extension VoxAuth.Reachability.NetworkStatus : Swift.Hashable {}
extension VoxAuth.Reachability.Connection : Swift.Equatable {}
extension VoxAuth.Reachability.Connection : Swift.Hashable {}
extension VoxAuth.CipherError : Swift.Equatable {}
extension VoxAuth.CipherError : Swift.Hashable {}
extension VoxAuth.Poly1305.Error : Swift.Equatable {}
extension VoxAuth.Poly1305.Error : Swift.Hashable {}
extension VoxAuth.SHA3.Variant : Swift.Equatable {}
extension VoxAuth.SHA3.Variant : Swift.Hashable {}
extension VoxAuth.AuthenticationMethodType : Swift.Equatable {}
extension VoxAuth.AuthenticationMethodType : Swift.Hashable {}
extension VoxAuth.AuthenticationMethodType : Swift.RawRepresentable {}
extension VoxAuth.StatusType : Swift.Equatable {}
extension VoxAuth.StatusType : Swift.Hashable {}
extension VoxAuth.StatusType : Swift.RawRepresentable {}
extension VoxAuth.BlockMode : Swift.Equatable {}
extension VoxAuth.BlockMode : Swift.Hashable {}
extension VoxAuth.Bit : Swift.Equatable {}
extension VoxAuth.Bit : Swift.Hashable {}
extension VoxAuth.Bit : Swift.RawRepresentable {}
extension VoxAuth.VOXAUTHSDKReturnType : Swift.Equatable {}
extension VoxAuth.VOXAUTHSDKReturnType : Swift.Hashable {}
extension VoxAuth.VOXAUTHSDKReturnType : Swift.RawRepresentable {}
extension VoxAuth.SHA2.Variant : Swift.Equatable {}
extension VoxAuth.SHA2.Variant : Swift.Hashable {}
extension VoxAuth.Rabbit.Error : Swift.Equatable {}
extension VoxAuth.Rabbit.Error : Swift.Hashable {}
extension VoxAuth.GetDeviceInfoCallback : Swift.Equatable {}
extension VoxAuth.GetDeviceInfoCallback : Swift.Hashable {}
extension VoxAuth.GetDeviceInfoCallback : Swift.RawRepresentable {}
extension VoxAuth.ChaCha20.Error : Swift.Equatable {}
extension VoxAuth.ChaCha20.Error : Swift.Hashable {}
extension VoxAuth.OTPAlgorithm : Swift.Equatable {}
extension VoxAuth.OTPAlgorithm : Swift.Hashable {}
extension VoxAuth.OTPAlgorithm : Swift.RawRepresentable {}
extension VoxAuth.Algorithm : Swift.Equatable {}
extension VoxAuth.Algorithm : Swift.Hashable {}
extension VoxAuth.PKCS5.PBKDF2.Error : Swift.Equatable {}
extension VoxAuth.PKCS5.PBKDF2.Error : Swift.Hashable {}
extension VoxAuth.PKCS5.PBKDF1.Error : Swift.Equatable {}
extension VoxAuth.PKCS5.PBKDF1.Error : Swift.Hashable {}
extension VoxAuth.PKCS5.PBKDF1.Variant : Swift.Equatable {}
extension VoxAuth.PKCS5.PBKDF1.Variant : Swift.Hashable {}
extension VoxAuth.Padding : Swift.Equatable {}
extension VoxAuth.Padding : Swift.Hashable {}
extension VoxAuth.Endianess : Swift.Equatable {}
extension VoxAuth.Endianess : Swift.Hashable {}
extension VoxAuth.CodReturnType : Swift.Equatable {}
extension VoxAuth.CodReturnType : Swift.Hashable {}
extension VoxAuth.CodReturnType : Swift.RawRepresentable {}
extension VoxAuth.AES.Error : Swift.Equatable {}
extension VoxAuth.AES.Error : Swift.Hashable {}
extension VoxAuth.AES.Variant : Swift.Equatable {}
extension VoxAuth.AES.Variant : Swift.Hashable {}
extension VoxAuth.AES.Variant : Swift.RawRepresentable {}
extension VoxAuth.Blowfish.Error : Swift.Equatable {}
extension VoxAuth.Blowfish.Error : Swift.Hashable {}
extension VoxAuth.HOTPError : Swift.Equatable {}
extension VoxAuth.HOTPError : Swift.Hashable {}
extension VoxAuth.HMAC.Error : Swift.Equatable {}
extension VoxAuth.HMAC.Error : Swift.Hashable {}
extension VoxAuth.HMAC.Variant : Swift.Equatable {}
extension VoxAuth.HMAC.Variant : Swift.Hashable {}
